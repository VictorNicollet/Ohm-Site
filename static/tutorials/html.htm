<p class="abstract">Learn how to write HTML templates that you can use to generate actual HTML pages using dynamic data.</p>

<h3>The hard way</h3>

<p>This section illustrates how you could generate HTML without using the HTML template system: the <code>Ohm.Html</code> module. The template system is just a clever way of generating all of this code for you.</p>

<p>HTML is generated by writing things to an "under construction" HTML object. You can write raw HTML, such as <code>&lt;b&gt;bold!&lt;/b&gt;</code>, you can write strings which are escaped so that special characters inside them do not wreak havoc on your page structure, and you can ask for JavaScript to be executed at specific points in your document &mdash; we'll discuss this last part in another tutorial.</p>

<p>Let's render a "Hello, [insert name here]!" message:</p>

<pre><div class="src">/ocaml/vHello.ml</div><{ocaml:open Ohm
open Ohm.Universal

let hello name html = 
  Html.str "<p>Hello, " html ;
  Html.esc name html ;
  Html.str "!</p>" html}></pre>

<p>This function takes an "under construction" HTML object parameter <code>html</code> and writes some HTML to it, along with the (escaped) name. In the Ohm vocabulary, this is known as a <b>writer</b>:</p>

<pre><div class="src">/ocaml/vHello.mli</div><{ocaml:val hello : string -> Ohm.Html.writer}></pre>

<p>While this method of programming writers can be acceptable for small applications with little HTML, it quickly gets very annoying. This is why Ohm provides an HTML template system.</p>

<h3>A simple template</h3>

<p>Here is an HTML template that is the equivalent of the above writer:</p>
<pre><div class="src">/asset/hello/index.htm</div>&lt;p&gt;Hello, <span class=comment>{this}</span>!&lt;/p&gt;</pre>
<p>This HTML template is compiled by the <code>ohm assets</code> (which runs as part of <code>make</code>) into a piece of OCaml code available as <code>Asset_Hello_Index.render</code>.</p>

<p>You don't need to touch this, ever, but for your curiosity, here's what the generated code looks like:</p>
<pre><div class="src">/_build/asset_Hello_Index.ml</div><{ocaml:let _source = AssetData.source
let render _data =
  let  _4 = _data in
  let  _5 = Ohm.Html.esc _4 in
  Ohm.Run.return (fun _html ->
    Buffer.add_substring _html.Ohm.Html.html _source 121 10 ;
    _5 _html ;
    Buffer.add_substring _html.Ohm.Html.html _source 115 6 ;
  )}></pre>

<p>Every HTML template is compiled to a function which takes a single argument (of whatever type matches the way it is used in the template itself) and returns a <a href="<{url:tutorials/run.htm}>">run-box</a> containing an HTML writer. The reason why a run-box is returned (instead of a normal value) is that some rendering operations may involve evaluating run-boxes: maybe a just-in-time database read is required to render something, or maybe the internationalization function (which is part of the run-box context) is used to translate some text...

<h3>Using the template</h3>

<p>We now have a clean way of generating an HTML writer. We need to make this writer compatible with function <code>Action.page</code>. This is done by using <code>O.print_page</code>:</p>

<pre><div class="src">/ocaml/cHello.ml</div><{ocaml:open Ohm
open Ohm.Universal

let () = UrlHello.def_generic (fun req res ->
  let! writer = ohm (Asset_Hello_Index.render name) in
  let  page   = O.render_page ~title:"Greeting" writer in
  return (Action.page page res))}></pre>

<p>The <code>O.print_page</code> function is known as a <b>renderer</b>: it takes an HTML writer and wraps it into a complete HTML document with a doctype, a content-type, stylesheets, scripts, a title, and so on &mdash; the original writer provides only a bit of the body, and leaves the rest to the renderer.</p>

<p>In fact, <code>O.print_page</code> is an excellent default renderer, because it provides sane defaults for what stylesheets and scripts are included. All you need to specify is the title. Most of the time, you will not need to use anything more complex than that.</p> 

<p>If you <code>make</code> your project now and visit <code>http://ice-cream.local/hello/World</code>, you should see a white page with a "Hello, World!" paragraph.</p>

<h3>Understanding template variables</h3>

<pre>&lt;p&gt;
  Welcome, <span class=comment>{human_name}</span>, welcome to city <span class=comment>{city_number}</span>!
&lt;/p&gt;</pre>

<p>You can print a variable to the template by writing its name between curly braces: <code>{number_of_fish}</code> or <code>{order_total}</code> or <code>{email}</code>. This will automatically HTML-escape the contents of the variable, which is expected to be a string. You can print an HTML writer instead of a string by appending a <code>verbatim</code> modifier: <code>{content|verbatim}</code> for example.</p>

<p>Any variable name that is legal in OCaml is a valid variable name, except for <code>this</code> and names that start with an underscore.</p>

<p>How are variable values extracted from the template argument? They are assumed to be methods: if the template argument is <code>data</code>, then the value of <code>email</code> is <code>data # email</code>. To save time, the compiler may try to evaluate each variable exactly once, even if it appears multiple times. A valid data object for the example at the top of this section would be: </p>

<pre><{ocaml:object 
  method human_name  = "Dr. Freeman"
  method city_number = "17" 
end}></pre>

<p>The special variable <code>this</code> represents the whole object. This is usually quite handy when there is only one variable, so you do not have to build an entire object with a single method inside.</p>

<h3>Formatting variables</h3>

<p>The city number should be a number, not a string. We would expect the template to perform the corresponding <code>string_of_int</code> conversion, and it just so happens that it can. The variable syntax lets you pipe the variable through unary functions until you obtain an HTML writer, at which point that writer will be output.</p>

<pre>&lt;p&gt;
  Welcome, <span class=comment>{human_name}</span>, welcome to city <span class=comment>{city_number|string_of_int|esc}</span>!
&lt;/p&gt;</pre>

<pre><{ocaml:object 
  method human_name  = "Dr. Freeman"
  method city_number = 17 
end}></pre>

<p>Here, <code>string_of_int</code> turns the integer into a string, and <code>esc</code> turns the string into an HTML writer that escapes the string it prints.</p>

<p>If for some insane reason you wished to print a string as-is, without any escaping (the recommended solution would be to create an HTML writer instead, but it's your funeral), you can use the <code>raw</code> unary function:</p>

<pre>&lt;div id="content"><span class=comment>{html|raw}</span>&lt;/div></pre>

<h3>Iterating through lists</h3>

<p>You can apply a sub-template to items of a list. For instance, to display a list of links that each have an URL and a label:</p>

<pre>&lt;ul&gt;
  <span class=comment>{#this}</span>
    &lt;li&gt;
      &lt;a href="<span class=comment>{url}</span>"&gt;<span class=comment>{label}</span>&lt;/a&gt;
    &lt;/li&gt;
  <span class=comment>{/#}</span>
&lt;/ul&gt;</pre>

<p>The opening tag <code>{#variable}</code> follows the same syntax as variables, meaning you can, say, flatten a list before rendering it: <code>{#list|List.flatten}</code>. The closing tag is always <code>{/#}</code>. Between the two, the "current data" is not the original template argument anymore: it becomes the current item in the list. This means that variables are now members of the current item in the list.</p>

<p>The corresponding type (and example data) for the example template above would be:</p>

<pre><{ocaml:val render : 
     < url : string ; label : string ; .. > list
  -> ('ctx,Ohm.Html.writer) Ohm.Run.t

let _ = render [ (object
  method url   = "..."
  method label = "..."
end) ; (object
  method url   = "..."
  method label = "..."
end) ]}></pre>

<p>You may sometimes want to display a special value when the list is empty by using the <code>{else}</code> keyword:</p>

<pre>&lt;ul&gt;
  <span class=comment>{#this}</span>
    &lt;li&gt;
      &lt;a href="<span class=comment>{url}</span>"&gt;<span class=comment>{label}</span>&lt;/a&gt;
    &lt;/li&gt;
  <span class=comment>{else}</span>
    &lt;li class="empty"&gt;Nothing to show here!&lt;/li&gt;
  <span class=comment>{/#}</span>
&lt;/ul&gt;</pre>

<p>The "current data" after the <code>{else}</code> is, of course, the original template argument.</p>
 
<h3>Conditional displays</h3>

<p>If you wish to only display a piece of HTML if a certain boolean condition is met, you can use the <code>{if}</code> construct:</p>

<pre>&lt;ul&gt;
  <span class=comment>{#this}</span>
    &lt;li<span class=comment>{if selected}</span>class="selected"<span class=comment>{/if}</span>&gt;
      &lt;a href="<span class=comment>{url}</span>"&gt;<span class=comment>{label}</span>&lt;/a&gt;
    &lt;/li&gt;
  <span class=comment>{/#}</span>
&lt;/ul&gt;</pre>

<p>As you might expect, the <code>{else}</code> keyword works.</p>

<h3>Optional values</h3>

<p>You can apply a sub-template to an optional value only if it is provided:</p>

<pre><span class=comment>{?admintools}</span>
  &lt;div class="admin"&gt;
    &lt;a href="<span class=comment>{kick}</span>"&gt;Kick&lt;/a&gt; &middot; &lt;a href="<span class=comment>{ban}</span>"&gt;Ban&lt;/a&gt;
  &lt;/div&gt;
<span class=comment>{/?}</span></pre>

<pre><{ocaml:val render :
     < admintools : < kick : string ; ban : string ; .. > option ; .. >
  -> ('ctx, Ohm.Html.writer) Ohm.Run.t}></pre>

<p>This syntax is identical to the list one, with the only difference being that it operates on an optional value instead of a list.</p>

<h3>Evaluating run-boxes</h3>

<p>In some cases, a value might be hidden in a run-box. One example is internationalization, where a run-box is necessary to extract the localization function from the context in order to use it. Another example is data which must be extracted from the database before it can be rendered. The problem is that run-boxes are used in monadic style, which means <b>there can be no unary function which turns a run-box into its value</b>.</p>

<p>The good news is that the template compiler provides a fake function which does just that, called <code>ohm</code>, and which is internally converted to the appropriate monadic style.</p>

<p>So, assuming <code>User.name</code> reads the name of an user from the database:</p>

<pre><{ocaml:val name : IUser.t -> (O.ctx, string option) Ohm.Run.t}></pre>

<p>Then you <i>could</i> write something like this:</p>

<pre><span class=comment>{?user|User.name|ohm}</span>
  Your name is : <span class=comment>{this}</span>
<span class=comment>{else}</span>
  You do not exist.
<span class=comment>{/?}</span></pre> 

<p>The context required to evaluate the user name run-box would then appear in the template function signature:</p>

<pre><{ocaml:val render : < user : IUser.t ; .. > -> (O.ctx, Ohm.Html.writer) Ohm.Run.t}></pre>

<p>In practice, it is not recommended to perform database queries directly from a template &mdash; but it is possible to provide un-evaluated run-boxes so that the template will only evaluate them if it actually needs their contents: this saves time if you often provide more data than the template actually needs.</p>

<h3>Including templates in other templates</h3>

<p>A template's <code>render</code> function is an unary function that returns a run-box which itself evaluates to a writer. This means that you can render template <code>asset/hello/test.htm</code> with parameter <code>data</code> by writing:</p>

<pre><span class=comment>{data|Asset_Hello_Test.render|ohm}</span></pre>

<p>If the template only expects an <code>unit</code> argument, you can even write:</p>

<pre><span class=comment>{Asset_Hello_Test.render|ohm}</span></pre>
